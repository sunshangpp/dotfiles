{"mode":"editor","version":1,"windowDimensions":{"x":45,"y":23,"width":1235,"height":777,"maximized":true},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/Users/ssun/Downloads/code_Biao.Li/log_aggregator"],"buffers":[{"text":"package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Record struct {\n\tcode     string\n\ttime_min string\n}\n\ntype Worker struct {\n\tcode          string\n\tcount_per_min int\n\ttime_min      string\n\tin            chan *Record\n\toutput        *bufio.Writer\n\tfeedback      chan int\n}\n\nfunc init_worker(code string, in chan *Record, feedback chan int) *Worker {\n\tw := &Worker{code, 0, \"\", in, nil, feedback}\n\treturn w\n}\n\nfunc aggregate_for_code(worker *Worker) {\n\tm := make(map[string]int)\n\tfor {\n\t\tr := <-worker.in\n\t\tif r == nil {\n\t\t\tbreak\n\t\t}\n\t\t//fmt.Printf(\"worker:%s get one record,%s,%s\\n\", worker.code, r.code, r.time_min)\n\t\tm[r.time_min] += 1\n\t}\n\toutput, _ := os.Create(gene_output_name(worker.code))\n\tworker.output = bufio.NewWriter(output)\n\tfmt.Fprintf(worker.output, \"# time, %s\\n\", worker.code)\n\tfor time_min, count := range m {\n\t\tfmt.Fprintf(worker.output, \"%s, %d\\n\", time_min, count)\n\t}\n\tworker.output.Flush()\n\toutput.Close()\n\tworker.feedback <- 1\n}\n\nfunc fields(line []byte) (r Record, e error) {\n\tvar begin, end = 0, 0\n\te = nil\n\tfor begin = 0; begin < len(line); begin++ {\n\t\tif line[begin] == '[' {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor end = begin + 1; end < len(line); end++ {\n\t\tif line[end] == ' ' {\n\t\t\tbreak\n\t\t}\n\t}\n\tr.time_min = string(line[begin+1 : end-3])\n\tif begin+1 >= end-3 {\n\t\te = errors.New(\"failed to parse time stamp\")\n\t}\n\t//for http code\n\ti := 2\n\tfor begin = end + 1; begin < len(line); begin++ {\n\t\tif line[begin] == '\"' {\n\t\t\tif i == 1 {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\ti--\n\t\t\t}\n\t\t}\n\t}\n\tbegin += 2\n\tfor end = begin; end < len(line); end++ {\n\t\tif line[end] == ' ' {\n\t\t\tbreak\n\t\t}\n\t}\n\tr.code = string(line[begin:end])\n\tif begin >= end {\n\t\te = errors.New(\"failed to parse http code\")\n\t}\n\treturn\n}\n\nfunc gene_output_name(code string) (fname string) {\n\tfname = strings.Join([]string{\"Code\", code, \"csv\"}, \".\")\n\treturn\n}\n\nfunc getWorkerByCode(m map[string]*Worker, code string, feedback chan int) *Worker {\n\tp, ok := m[code]\n\tif ok {\n\t\treturn p\n\t}\n\tp = init_worker(code, make(chan *Record, 100), feedback)\n\tm[code] = p\n\tgo aggregate_for_code(p)\n\treturn p\n}\n\nfunc DispatcherAll(input_ch chan *Record, parent_feedback chan int) {\n\tworkers := make(map[string]*Worker)\n\tworker_feedback := make(chan int, 10)\n\tcount := 0\n\tfor {\n\t\tr := <-input_ch\n\t\tif r == nil {\n\t\t\tbreak\n\t\t}\n\t\tcount++\n\t\tw := getWorkerByCode(workers, r.code, worker_feedback)\n\t\tw.in <- r\n\t}\n\t//stop the all of dispatcher_by_code\n\tfor _, w := range workers {\n\t\tw.in <- nil\n\t}\n\tfor _ = range workers {\n\t\t<-worker_feedback\n\t}\n\n\tfmt.Printf(\"Porcess %d records\\n\", count)\n\tparent_feedback <- 1\n}\n\n/*\n* assumption:\n* 1, every line of one log file MUST be in the STANDARD common log format\n*\n* parameters:\n* \t\trd can be any io stream which implements the interface of io.Reader, such as a file, STDIN.\n */\nfunc parse_one_file(rd io.Reader, output_ch chan *Record, parent_feedback chan int) {\n\n\tvar count int = 0\n\treader := bufio.NewReader(rd)\n\tfor {\n\t\tdata, _, err := reader.ReadLine()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tc := len(data)\n\t\tif c == 0 {\n\t\t\tcount += 1\n\t\t\tcontinue\n\t\t}\n\t\tcount += c + 1\n\t\tr, e := fields(data)\n\t\tif e != nil {\n\t\t\tcontinue\n\t\t}\n\t\t//fmt.Printf(\"@{%s,%s}\\n\", r.code, r.time_min)\n\t\toutput_ch <- &r\n\t}\n\n\tfmt.Printf(\"read %d bytes\\n\", count)\n\tparent_feedback <- 1\n}\n\nfunc main() {\n\n\tvar MAX_PARALLEL int = 2\n\n\t//launch DispatcherAll\n\tdispatcher_all_feedback := make(chan int)\n\trecord_channel := make(chan *Record, 200)\n\tgo DispatcherAll(record_channel, dispatcher_all_feedback)\n\n\tparser_feedback := make(chan int, MAX_PARALLEL)\n\tprocess_count := 0\n\tfor _, a := range os.Args[1:] {\n\t\tfile, err := os.Open(a)\n\t\tdefer file.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Printf(\"Open file:%s\\n\", a)\n\t\tgo parse_one_file(file, record_channel, parser_feedback)\n\t\tprocess_count++\n\t\t//only allow number of MAX_PARALLEL goroutines simultaneously to run;\n\t\tif process_count >= MAX_PARALLEL {\n\t\t\t<-parser_feedback\n\t\t\tprocess_count--\n\t\t}\n\t}\n\n\tfor ; process_count > 0; process_count-- {\n\t\t<-parser_feedback\n\t}\n\n\t//notify and waiting for DispatcherAll\n\trecord_channel <- nil\n\t<-dispatcher_all_feedback\n\n\tfmt.Printf(\"Everything is OK\\n\")\n}\n","markers":{"markers":{"1":{"id":1,"range":[[20,0],[20,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":4,"goalBufferRange":null},"deserializer":"Marker"},"256":{"id":256,"range":[[20,0],[20,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[{"deserializer":"Checkpoint"}],"redoStack":[{"patches":[{"oldRange":[[12,3],[12,4]],"newRange":[[12,3],[12,3]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[12,2],[12,3]],"newRange":[[12,2],[12,2]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[12,1],[12,2]],"newRange":[[12,1],[12,1]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[12,0],[12,1]],"newRange":[[12,0],[12,0]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"}],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/ssun/Downloads/code_Biao.Li/log_aggregator/p.go","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"57e8ed1b301ac95a15d1e8c12740d311589f6542","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":4,"softTabs":false,"displayBuffer":{"id":5,"softWrapped":false,"editorWidthInChars":null,"scrollTop":18,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/ssun/Downloads/code_Biao.Li/log_aggregator/p.go","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/ssun/Downloads/code_Biao.Li/log_aggregator/p.go","focused":true,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-go","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"sublime-tabs":{"directoryExpansionStates":{"/Users/ssun/Downloads/code_Biao.Li/log_aggregator":{"isExpanded":true,"entries":{}}},"selectedPath":"/Users/ssun/Downloads/code_Biao.Li/log_aggregator/p.go","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200},"fuzzy-finder":{"/Users/ssun/Downloads/code_Biao.Li/log_aggregator/p.go":1426794502468},"metrics":{"sessionLength":26727}}}