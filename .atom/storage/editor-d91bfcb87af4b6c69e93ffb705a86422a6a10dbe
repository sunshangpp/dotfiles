{"version":1,"windowDimensions":{"x":0,"y":23,"width":1280,"height":777,"maximized":true},"grammars":{"grammarOverridesByPath":{}},"project":{"deserializer":"Project","paths":["/Users/ssun/Projects/twemproxy/src"],"buffers":[{"text":"/*\n * twemproxy - A fast and lightweight proxy for memcached protocol.\n * Copyright (C) 2011 Twitter, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n\n#include <nc_core.h>\n#include <nc_conf.h>\n#include <nc_signal.h>\n\n#define NC_CONF_PATH        \"conf/nutcracker.yml\"\n\n#define NC_LOG_DEFAULT      LOG_NOTICE\n#define NC_LOG_MIN          LOG_EMERG\n#define NC_LOG_MAX          LOG_PVERB\n#define NC_LOG_PATH         NULL\n\n#define NC_STATS_PORT       STATS_PORT\n#define NC_STATS_ADDR       STATS_ADDR\n#define NC_STATS_INTERVAL   STATS_INTERVAL\n\n#define NC_PID_FILE         NULL\n\n#define NC_MBUF_SIZE        MBUF_SIZE\n#define NC_MBUF_MIN_SIZE    MBUF_MIN_SIZE\n#define NC_MBUF_MAX_SIZE    MBUF_MAX_SIZE\n\nstatic int show_help;\nstatic int show_version;\nstatic int test_conf;\nstatic int daemonize;\nstatic int describe_stats;\n\nstatic struct option long_options[] = {\n    { \"help\",           no_argument,        NULL,   'h' },\n    { \"version\",        no_argument,        NULL,   'V' },\n    { \"test-conf\",      no_argument,        NULL,   't' },\n    { \"daemonize\",      no_argument,        NULL,   'd' },\n    { \"describe-stats\", no_argument,        NULL,   'D' },\n    { \"verbose\",        required_argument,  NULL,   'v' },\n    { \"output\",         required_argument,  NULL,   'o' },\n    { \"conf-file\",      required_argument,  NULL,   'c' },\n    { \"stats-port\",     required_argument,  NULL,   's' },\n    { \"stats-interval\", required_argument,  NULL,   'i' },\n    { \"stats-addr\",     required_argument,  NULL,   'a' },\n    { \"pid-file\",       required_argument,  NULL,   'p' },\n    { \"mbuf-size\",      required_argument,  NULL,   'm' },\n    { NULL,             0,                  NULL,    0  }\n};\n\nstatic char short_options[] = \"hVtdDv:o:c:s:i:a:p:m:\";\n\nstatic rstatus_t\nnc_daemonize(int dump_core)\n{\n    rstatus_t status;\n    pid_t pid, sid;\n    int fd;\n\n    pid = fork();\n    switch (pid) {\n    case -1:\n        log_error(\"fork() failed: %s\", strerror(errno));\n        return NC_ERROR;\n\n    case 0:\n        break;\n\n    default:\n        /* parent terminates */\n        _exit(0);\n    }\n\n    /* 1st child continues and becomes the session leader */\n\n    sid = setsid();\n    if (sid < 0) {\n        log_error(\"setsid() failed: %s\", strerror(errno));\n        return NC_ERROR;\n    }\n\n    if (signal(SIGHUP, SIG_IGN) == SIG_ERR) {\n        log_error(\"signal(SIGHUP, SIG_IGN) failed: %s\", strerror(errno));\n        return NC_ERROR;\n    }\n\n    pid = fork();\n    switch (pid) {\n    case -1:\n        log_error(\"fork() failed: %s\", strerror(errno));\n        return NC_ERROR;\n\n    case 0:\n        break;\n\n    default:\n        /* 1st child terminates */\n        _exit(0);\n    }\n\n    /* 2nd child continues */\n\n    /* change working directory */\n    if (dump_core == 0) {\n        status = chdir(\"/\");\n        if (status < 0) {\n            log_error(\"chdir(\\\"/\\\") failed: %s\", strerror(errno));\n            return NC_ERROR;\n        }\n    }\n\n    /* clear file mode creation mask */\n    umask(0);\n\n    /* redirect stdin, stdout and stderr to \"/dev/null\" */\n\n    fd = open(\"/dev/null\", O_RDWR);\n    if (fd < 0) {\n        log_error(\"open(\\\"/dev/null\\\") failed: %s\", strerror(errno));\n        return NC_ERROR;\n    }\n\n    status = dup2(fd, STDIN_FILENO);\n    if (status < 0) {\n        log_error(\"dup2(%d, STDIN) failed: %s\", fd, strerror(errno));\n        close(fd);\n        return NC_ERROR;\n    }\n\n    status = dup2(fd, STDOUT_FILENO);\n    if (status < 0) {\n        log_error(\"dup2(%d, STDOUT) failed: %s\", fd, strerror(errno));\n        close(fd);\n        return NC_ERROR;\n    }\n\n    status = dup2(fd, STDERR_FILENO);\n    if (status < 0) {\n        log_error(\"dup2(%d, STDERR) failed: %s\", fd, strerror(errno));\n        close(fd);\n        return NC_ERROR;\n    }\n\n    if (fd > STDERR_FILENO) {\n        status = close(fd);\n        if (status < 0) {\n            log_error(\"close(%d) failed: %s\", fd, strerror(errno));\n            return NC_ERROR;\n        }\n    }\n\n    return NC_OK;\n}\n\nstatic void\nnc_print_run(struct instance *nci)\n{\n    int status;\n    struct utsname name;\n\n    status = uname(&name);\n    if (status < 0) {\n        loga(\"nutcracker-%s started on pid %d\", NC_VERSION_STRING, nci->pid);\n    } else {\n        loga(\"nutcracker-%s built for %s %s %s started on pid %d\",\n             NC_VERSION_STRING, name.sysname, name.release, name.machine,\n             nci->pid);\n    }\n\n    loga(\"run, rabbit run / dig that hole, forget the sun / \"\n         \"and when at last the work is done / don't sit down / \"\n         \"it's time to dig another one\");\n}\n\nstatic void\nnc_print_done(void)\n{\n    loga(\"done, rabbit done\");\n}\n\nstatic void\nnc_show_usage(void)\n{\n    log_stderr(\n        \"Usage: nutcracker [-?hVdDt] [-v verbosity level] [-o output file]\" CRLF\n        \"                  [-c conf file] [-s stats port] [-a stats addr]\" CRLF\n        \"                  [-i stats interval] [-p pid file] [-m mbuf size]\" CRLF\n        \"\");\n    log_stderr(\n        \"Options:\" CRLF\n        \"  -h, --help             : this help\" CRLF\n        \"  -V, --version          : show version and exit\" CRLF\n        \"  -t, --test-conf        : test configuration for syntax errors and exit\" CRLF\n        \"  -d, --daemonize        : run as a daemon\" CRLF\n        \"  -D, --describe-stats   : print stats description and exit\");\n    log_stderr(\n        \"  -v, --verbose=N        : set logging level (default: %d, min: %d, max: %d)\" CRLF\n        \"  -o, --output=S         : set logging file (default: %s)\" CRLF\n        \"  -c, --conf-file=S      : set configuration file (default: %s)\" CRLF\n        \"  -s, --stats-port=N     : set stats monitoring port (default: %d)\" CRLF\n        \"  -a, --stats-addr=S     : set stats monitoring ip (default: %s)\" CRLF\n        \"  -i, --stats-interval=N : set stats aggregation interval in msec (default: %d msec)\" CRLF\n        \"  -p, --pid-file=S       : set pid file (default: %s)\" CRLF\n        \"  -m, --mbuf-size=N      : set size of mbuf chunk in bytes (default: %d bytes)\" CRLF\n        \"\",\n        NC_LOG_DEFAULT, NC_LOG_MIN, NC_LOG_MAX,\n        NC_LOG_PATH != NULL ? NC_LOG_PATH : \"stderr\",\n        NC_CONF_PATH,\n        NC_STATS_PORT, NC_STATS_ADDR, NC_STATS_INTERVAL,\n        NC_PID_FILE != NULL ? NC_PID_FILE : \"off\",\n        NC_MBUF_SIZE);\n}\n\nstatic rstatus_t\nnc_create_pidfile(struct instance *nci)\n{\n    char pid[NC_UINTMAX_MAXLEN];\n    int fd, pid_len;\n    ssize_t n;\n\n    fd = open(nci->pid_filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n    if (fd < 0) {\n        log_error(\"opening pid file '%s' failed: %s\", nci->pid_filename,\n                  strerror(errno));\n        return NC_ERROR;\n    }\n    nci->pidfile = 1;\n\n    pid_len = nc_snprintf(pid, NC_UINTMAX_MAXLEN, \"%d\", nci->pid);\n\n    n = nc_write(fd, pid, pid_len);\n    if (n < 0) {\n        log_error(\"write to pid file '%s' failed: %s\", nci->pid_filename,\n                  strerror(errno));\n        return NC_ERROR;\n    }\n\n    close(fd);\n\n    return NC_OK;\n}\n\nstatic void\nnc_remove_pidfile(struct instance *nci)\n{\n    int status;\n\n    status = unlink(nci->pid_filename);\n    if (status < 0) {\n        log_error(\"unlink of pid file '%s' failed, ignored: %s\",\n                  nci->pid_filename, strerror(errno));\n    }\n}\n\nstatic void\nnc_set_default_options(struct instance *nci)\n{\n    int status;\n\n    nci->ctx = NULL;\n\n    nci->log_level = NC_LOG_DEFAULT;\n    nci->log_filename = NC_LOG_PATH;\n\n    nci->conf_filename = NC_CONF_PATH;\n\n    nci->stats_port = NC_STATS_PORT;\n    nci->stats_addr = NC_STATS_ADDR;\n    nci->stats_interval = NC_STATS_INTERVAL;\n\n    status = nc_gethostname(nci->hostname, NC_MAXHOSTNAMELEN);\n    if (status < 0) {\n        log_warn(\"gethostname failed, ignored: %s\", strerror(errno));\n        nc_snprintf(nci->hostname, NC_MAXHOSTNAMELEN, \"unknown\");\n    }\n    nci->hostname[NC_MAXHOSTNAMELEN - 1] = '\\0';\n\n    nci->mbuf_chunk_size = NC_MBUF_SIZE;\n\n    nci->pid = (pid_t)-1;\n    nci->pid_filename = NULL;\n    nci->pidfile = 0;\n}\n\nstatic rstatus_t\nnc_get_options(int argc, char **argv, struct instance *nci)\n{\n    int c, value;\n\n    opterr = 0;\n\n    for (;;) {\n        c = getopt_long(argc, argv, short_options, long_options, NULL);\n        if (c == -1) {\n            /* no more options */\n            break;\n        }\n\n        switch (c) {\n        case 'h':\n            show_version = 1;\n            show_help = 1;\n            break;\n\n        case 'V':\n            show_version = 1;\n            break;\n\n        case 't':\n            test_conf = 1;\n            break;\n\n        case 'd':\n            daemonize = 1;\n            break;\n\n        case 'D':\n            describe_stats = 1;\n            show_version = 1;\n            break;\n\n        case 'v':\n            value = nc_atoi(optarg, strlen(optarg));\n            if (value < 0) {\n                log_stderr(\"nutcracker: option -v requires a number\");\n                return NC_ERROR;\n            }\n            nci->log_level = value;\n            break;\n\n        case 'o':\n            nci->log_filename = optarg;\n            break;\n\n        case 'c':\n            nci->conf_filename = optarg;\n            break;\n\n        case 's':\n            value = nc_atoi(optarg, strlen(optarg));\n            if (value < 0) {\n                log_stderr(\"nutcracker: option -s requires a number\");\n                return NC_ERROR;\n            }\n            if (!nc_valid_port(value)) {\n                log_stderr(\"nutcracker: option -s value %d is not a valid \"\n                           \"port\", value);\n                return NC_ERROR;\n            }\n\n            nci->stats_port = (uint16_t)value;\n            break;\n\n        case 'i':\n            value = nc_atoi(optarg, strlen(optarg));\n            if (value < 0) {\n                log_stderr(\"nutcracker: option -i requires a number\");\n                return NC_ERROR;\n            }\n\n            nci->stats_interval = value;\n            break;\n\n        case 'a':\n            nci->stats_addr = optarg;\n            break;\n\n        case 'p':\n            nci->pid_filename = optarg;\n            break;\n\n        case 'm':\n            value = nc_atoi(optarg, strlen(optarg));\n            if (value <= 0) {\n                log_stderr(\"nutcracker: option -m requires a non-zero number\");\n                return NC_ERROR;\n            }\n\n            if (value < NC_MBUF_MIN_SIZE || value > NC_MBUF_MAX_SIZE) {\n                log_stderr(\"nutcracker: mbuf chunk size must be between %zu and\"\n                           \" %zu bytes\", NC_MBUF_MIN_SIZE, NC_MBUF_MAX_SIZE);\n                return NC_ERROR;\n            }\n\n            nci->mbuf_chunk_size = (size_t)value;\n            break;\n\n        case '?':\n            switch (optopt) {\n            case 'o':\n            case 'c':\n            case 'p':\n                log_stderr(\"nutcracker: option -%c requires a file name\",\n                           optopt);\n                break;\n\n            case 'm':\n            case 'v':\n            case 's':\n            case 'i':\n                log_stderr(\"nutcracker: option -%c requires a number\", optopt);\n                break;\n\n            case 'a':\n                log_stderr(\"nutcracker: option -%c requires a string\", optopt);\n                break;\n\n            default:\n                log_stderr(\"nutcracker: invalid option -- '%c'\", optopt);\n                break;\n            }\n            return NC_ERROR;\n\n        default:\n            log_stderr(\"nutcracker: invalid option -- '%c'\", optopt);\n            return NC_ERROR;\n\n        }\n    }\n\n    return NC_OK;\n}\n\n/*\n * Returns true if configuration file has a valid syntax, otherwise\n * returns false\n */\nstatic bool\nnc_test_conf(struct instance *nci)\n{\n    struct conf *cf;\n\n    cf = conf_create(nci->conf_filename);\n    if (cf == NULL) {\n        log_stderr(\"nutcracker: configuration file '%s' syntax is invalid\",\n                   nci->conf_filename);\n        return false;\n    }\n\n    conf_destroy(cf);\n\n    log_stderr(\"nutcracker: configuration file '%s' syntax is ok\",\n               nci->conf_filename);\n    return true;\n}\n\nstatic rstatus_t\nnc_pre_run(struct instance *nci)\n{\n    rstatus_t status;\n\n    status = log_init(nci->log_level, nci->log_filename);\n    if (status != NC_OK) {\n        return status;\n    }\n\n    if (daemonize) {\n        status = nc_daemonize(1);\n        if (status != NC_OK) {\n            return status;\n        }\n    }\n\n    nci->pid = getpid();\n\n    status = signal_init();\n    if (status != NC_OK) {\n        return status;\n    }\n\n    if (nci->pid_filename) {\n        status = nc_create_pidfile(nci);\n        if (status != NC_OK) {\n            return status;\n        }\n    }\n\n    nc_print_run(nci);\n\n    return NC_OK;\n}\n\nstatic void\nnc_post_run(struct instance *nci)\n{\n    if (nci->pidfile) {\n        nc_remove_pidfile(nci);\n    }\n\n    signal_deinit();\n\n    nc_print_done();\n\n    log_deinit();\n}\n\nstatic void\nnc_run(struct instance *nci)\n{\n    rstatus_t status;\n    struct context *ctx;\n\n    ctx = core_start(nci);\n    if (ctx == NULL) {\n        return;\n    }\n\n    /* run rabbit run */\n    for (;;) {\n        status = core_loop(ctx);\n        if (status != NC_OK) {\n            break;\n        }\n    }\n\n    core_stop(ctx);\n}\n\nint\nmain(int argc, char **argv)\n{\n    rstatus_t status;\n    struct instance nci;\n\n    nc_set_default_options(&nci);\n\n    status = nc_get_options(argc, argv, &nci);\n    if (status != NC_OK) {\n        nc_show_usage();\n        exit(1);\n    }\n\n    if (show_version) {\n        log_stderr(\"This is nutcracker-%s\" CRLF, NC_VERSION_STRING);\n        if (show_help) {\n            nc_show_usage();\n        }\n\n        if (describe_stats) {\n            stats_describe();\n        }\n\n        exit(0);\n    }\n\n    if (test_conf) {\n        if (!nc_test_conf(&nci)) {\n            exit(1);\n        }\n        exit(0);\n    }\n\n    status = nc_pre_run(&nci);\n    if (status != NC_OK) {\n        nc_post_run(&nci);\n        exit(1);\n    }\n\n    nc_run(&nci);\n\n    nc_post_run(&nci);\n\n    exit(1);\n}\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"nextMarkerId":29,"id":"0","maintainHistory":false,"markersById":{"0-28":{"range":{"start":{"row":53,"column":16},"end":{"row":53,"column":16}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap"}},"version":2},"1":{"nextMarkerId":0,"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"nextMarkerId":5,"id":"2","maintainHistory":true,"markersById":{"2-0":{"range":{"start":{"row":53,"column":16},"end":{"row":53,"column":16}},"properties":{"type":"selection","goalScreenRange":null,"autoscroll":false},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2}},"nextMarkerLayerId":3,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/ssun/Projects/twemproxy/src/nc.c","digestWhenLastPersisted":"8d356327e70c6fe0cccf5fcd14fd9025cec14cd5","preferredLineEnding":null,"deserializer":"TextBuffer","version":4}]},"workspace":{"deserializer":"Workspace","paneContainer":{"deserializer":"PaneContainer","version":1,"root":{"deserializer":"Pane","id":3,"items":[{"deserializer":"TextEditor","id":4,"softTabs":true,"firstVisibleScreenRow":41,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":5,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/Users/ssun/Projects/twemproxy/src/nc.c","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"}],"activeItemURI":"/Users/ssun/Projects/twemproxy/src/nc.c","focused":true,"flexScale":1},"activePaneId":3},"packagesWithActiveGrammars":["language-c","language-hyperlink","language-todo"],"destroyedItemURIs":[]},"packageStates":{"linter":{"scope":"File"},"fuzzy-finder":{"/Users/ssun/Projects/twemproxy/src/nc.c":1465846663760},"metrics":{"sessionLength":182758},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/Users/ssun/Projects/twemproxy/src":{"isExpanded":true,"entries":{"event":{"isExpanded":false,"entries":{}},"hashkit":{"isExpanded":false,"entries":{}},"proto":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/Users/ssun/Projects/twemproxy/src/nc.c","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}},"fullScreen":false}