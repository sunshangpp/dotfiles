{"mode":"editor","version":1,"windowDimensions":{"x":45,"y":23,"width":1235,"height":777,"maximized":false},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/Users/ssun/Projects/tumblr/franz/src/main/scala/com/tumblr/franz"],"buffers":[{"text":"package com.tumblr.franz\npackage outputs\n\nimport akka.actor.{Actor, Props}\nimport com.tumblr.franz.config.FranzConfig\nimport com.typesafe.scalalogging.slf4j.LazyLogging\nimport tumblrkafka.api.FetchRequest\nimport tumblrkafka.consumer.SimpleConsumer\nimport tumblrkafka.message.MessageAndOffset\n\nobject Fetcher {\n  sealed trait Request { def offset: Long }\n\n  case object Oldest extends Request { def offset = -2L }\n  case object Latest extends Request { def offset = -1L }\n  case class FromOffset(offset: Long) extends Request\n  case class Buffer(messages: List[MessageAndOffset], orderOffset: Long)\n\n  def props(config: FranzConfig, metrics: FranzMetrics): Props =\n    Props(classOf[Fetcher], config, metrics)\n}\n\nclass Fetcher(val config: FranzConfig, val metrics: FranzMetrics)\n  extends Actor with LazyLogging {\n\n  logger.info(\"starting actor...\")\n\n  import Fetcher._\n\n  val Host = \"localhost\"\n  val Partition = 0\n  val BufferSize = 8388608 // bytes\n  val TimeOut = 5000 // milliseconds\n\n  val consumer = new SimpleConsumer(Host, config.constants.kafkaPort, TimeOut, BufferSize)\n  var prefetch = List[MessageAndOffset]()\n\n  def fetch(offset: Long): List[MessageAndOffset] = {\n    logger.debug(s\"attempting to fetch from message $offset\")\n    val fetch = consumer.fetch(new FetchRequest(config.constants.logTopic, Partition, offset, BufferSize))\n\n    if (fetch.nonEmpty) {\n      logger.debug(s\"fetched ${fetch.size} new messages.\")\n      fetch.iterator.toList\n    } else {\n      logger.warn(s\"no new messages.\")\n      List[MessageAndOffset]()\n    }\n  }\n\n  def fulfillOrder(requestOffset: Long): List[MessageAndOffset] = {\n    val messages = if (prefetch.nonEmpty) prefetch else fetch(requestOffset)\n    logger.debug(s\"fulfilling order with ${messages.size} new messages.\")\n    messages\n  }\n\n  override def receive: Receive = {\n    case req: Request =>\n      val requestOffset = if (req.offset < 0) {\n        consumer.getOffsetsBefore(config.constants.logTopic, Partition, req.offset, 1)(0)\n      } else req.offset\n\n      logger.debug(s\"order recieved with offset $requestOffset\")\n      val messages = fulfillOrder(requestOffset)\n\n      logger.debug(s\"sending buffer request of ${messages.size} messages.\")\n      sender ! Buffer(messages, requestOffset)\n\n      if (messages.nonEmpty) {\n        logger.debug(\"prefetching for next order\")\n        prefetch = fetch(messages.last.offset)\n      }\n\n    case _ => logger.warn(\"received bad message\")\n  }\n}\n","markerStore":{"nextMarkerId":2,"markersById":{"0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","editorId":6,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":2,"nextCheckpointId":2,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/ssun/Projects/tumblr/franz/src/main/scala/com/tumblr/franz/outputs/Fetcher.scala","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"e0d4f91c38e44b01ec92e8dfc7d20c1cfd14f45b","deserializer":"TextBuffer","version":2},{"text":"package com.tumblr.franz\npackage outputs\n\nimport akka.actor.{Actor, Props}\nimport com.tumblr.franz.config.{FranzConfig, Output}\nimport com.typesafe.scalalogging.slf4j.LazyLogging\n\nimport scala.concurrent.duration._\nimport scala.concurrent.{Await, Future}\nimport scala.language.postfixOps\nimport scala.util.{Failure, Success}\n\nobject Persistor {\n  case class Persist(offset: Long)\n\n  case object LastPersisted\n  case object FlushToDisk\n  case object Shutdown\n\n  def props(outputConfig: Output, config: FranzConfig, metrics: FranzMetrics): Props =\n    Props(classOf[Persistor], outputConfig, config, metrics)\n}\n\nclass Persistor(val outputConfig: Output, val config: FranzConfig, val metrics: FranzMetrics)\n  extends Actor with LocalFileOffset with LazyLogging {\n\n  logger.info(\"starting actor...\")\n\n  import Persistor._\n  import context._\n\n  // TODO: this execution context is pulled in to run the persistence future, we need to create\n  // TODO: a separate thread pool for it to make sure the it always gets a chance to run\n//  implicit val ec = dispatcher\n  lazy val offsetFile = new java.io.File(config.constants.storageDir + s\"/${outputConfig.name}.store\")\n\n  var highestSentOffset = 0L\n  var persistFuture: Future[Unit] = null\n\n  // try to flush the offset to disk every second, but the flush is not guaranteed\n  // because this FlushToDisk message is only processed when the actor is in `idle` mode\n  system.scheduler.schedule(1 second, 1 second, self, FlushToDisk)\n\n  /**\n   * Persist the offset received\n   */\n  def persist: Receive = {\n    case Persist(offset) =>\n      if (offset > highestSentOffset) highestSentOffset = offset\n      logger.debug(s\"try persisting offset: $offset\")\n      become(busy)\n      persistFuture = Future { setOffset(offset) }\n      persistFuture onComplete {\n        case Success(_) =>\n          become(idle)\n\n        case Failure(e: Throwable) =>\n          logger.error(s\"failed to persist offset $offset -- ${e.toString}}\")\n          become(idle)\n      }\n  }\n\n  /**\n   * Skip the persist request\n   */\n  def skip: Receive = {\n    case Persist(offset) =>\n      if (offset > highestSentOffset) highestSentOffset = offset\n      logger.debug(s\"skip persisting offset: $offset\")\n  }\n\n  /**\n   * Make sure the highest offset is persisted and flush the data to disk\n   */\n  def flush: Receive = {\n    case FlushToDisk =>\n      if (highestSentOffset > getOffset) setOffset(highestSentOffset)\n      logger.debug(s\"flushing persisted offset to disk...\")\n      flushToDisk\n  }\n\n  /**\n   * Answer the sender with the last persisted offset\n   */\n  def answer: Receive =  { case LastPersisted => sender ! getOffset }\n\n  def idle: Receive = persist orElse flush orElse answer\n  def busy: Receive = skip orElse answer\n\n  override def receive: Receive = idle\n\n  /**\n   * Make sure the persistFuture completes and then synchronously persist the highest offset\n   */\n  override def postStop(): Unit = {\n    try {\n      Await.result(persistFuture, 1 seconds)\n    } catch { case _: Throwable => } finally {\n      if (highestSentOffset > 0) {\n        logger.info(s\"persisting the highest offset: $highestSentOffset before shutting down\")\n        setOffset(highestSentOffset)\n      }\n    }\n  }\n\n}\n","markerStore":{"nextMarkerId":6,"markersById":{"0":{"range":{"start":{"row":28,"column":20},"end":{"row":28,"column":20}},"properties":{"type":"selection","editorId":10,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true},"5":{"range":{"start":{"row":28,"column":20},"end":{"row":28,"column":20}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":true}},"version":2},"history":{"version":2,"nextCheckpointId":2,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/ssun/Projects/tumblr/franz/src/main/scala/com/tumblr/franz/outputs/Persistor.scala","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"313851206dc2290c36911062d2b6cb1fd8e50376","deserializer":"TextBuffer","version":2}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":6,"softTabs":true,"displayBuffer":{"id":7,"softWrapped":false,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/ssun/Projects/tumblr/franz/src/main/scala/com/tumblr/franz/outputs/Fetcher.scala","largeFileMode":false,"deserializer":"TokenizedBuffer"},"largeFileMode":false,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":10,"softTabs":true,"displayBuffer":{"id":11,"softWrapped":false,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/ssun/Projects/tumblr/franz/src/main/scala/com/tumblr/franz/outputs/Persistor.scala","largeFileMode":false,"deserializer":"TokenizedBuffer"},"largeFileMode":false,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/ssun/Projects/tumblr/franz/src/main/scala/com/tumblr/franz/outputs/Persistor.scala","focused":true,"flexScale":1,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-scala","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"linter":{"scope":"File"},"fuzzy-finder":{"/Users/ssun/Projects/tumblr/franz/src/main/scala/com/tumblr/franz/outputs/Fetcher.scala":1436906479408,"/Users/ssun/Projects/tumblr/franz/src/main/scala/com/tumblr/franz/outputs/Persistor.scala":1436906481272},"keybinding-resolver":{},"metrics":{"sessionLength":20299},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/Users/ssun/Projects/tumblr/franz/src/main/scala/com/tumblr/franz":{"isExpanded":true,"entries":{"config":{"isExpanded":true,"entries":{}},"inputs":{"isExpanded":false,"entries":{}},"jmx":{"isExpanded":false,"entries":{}},"outputs":{"isExpanded":true,"entries":{}}}}},"selectedPath":"/Users/ssun/Projects/tumblr/franz/src/main/scala/com/tumblr/franz/outputs/Persistor.scala","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}